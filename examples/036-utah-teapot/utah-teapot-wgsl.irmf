/*{
  date: "2026-01-28",
  irmf: "1.0",
  language: "wgsl",
  materials: ["porcelain"],
  min: [-3.3, 0.0, -2.1],
  max: [3.6, 3.3, 2.1],
  title: "Utah Teapot (Solid Bezier)",
  units: "mm",
  version: "1.0",
}*/

fn bezier(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>, t: f32) -> vec2<f32> {
    let u = 1.0 - t;
    return u*u*u*p0 + 3.0*u*u*t*p1 + 3.0*u*t*t*p2 + t*t*t*p3;
}

fn intersectBezier(p: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>) -> i32 {
    var count: i32 = 0; var prev = p0; let samples: f32 = 20.0;
    for (var i: i32 = 1; i <= 20; i = i + 1) {
        let curr = bezier(p0, p1, p2, p3, f32(i) / samples);
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            let x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) { count = count + 1; }
        }
        prev = curr;
    }
    return count;
}

fn intersectLine(p: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>) -> i32 {
    if (((p0.y <= p.y && p.y < p1.y) || (p1.y <= p.y && p.y < p0.y))) {
        let x = p0.x + (p1.x - p0.x) * (p.y - p0.y) / (p1.y - p0.y);
        if (x > p.x) { return 1; }
    }
    return 0;
}

fn bspline(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>, p4: vec2<f32>, p5: vec2<f32>, p6: vec2<f32>, p7: vec2<f32>, p8: vec2<f32>, t: f32) -> vec2<f32> {
    let mt = t * 6.0; let seg = i32(floor(mt)); let f = mt - f32(seg);
    if (seg == 0) { return bezier(p0, p1, p2, (p2+p3)*0.5, f); }
    if (seg == 5) { return bezier((p5+p6)*0.5, p6, p7, p8, f); }
    var pts = array<vec2<f32>, 9>(p0, p1, p2, p3, p4, p5, p6, p7, p8);
    let c0 = (pts[seg]+pts[seg+1])*0.5; let c1 = pts[seg+1]; let c2 = pts[seg+2]; let c3 = (pts[seg+2]+pts[seg+3])*0.5;
    return bezier(c0, c1, c2, c3, f);
}

fn intersectBSpline(p: vec2<f32>) -> i32 {
    var count: i32 = 0;
    let p0 = vec2<f32>(1.4, 2.25); let p1 = vec2<f32>(1.3, 2.25); let p2 = vec2<f32>(1.2, 2.25);
    let p3 = vec2<f32>(1.2, 2.15); let p4 = vec2<f32>(1.5, 2.12); let p5 = vec2<f32>(2.0, 0.6);
    let p6 = vec2<f32>(1.4, 0.2); let p7 = vec2<f32>(1.3, 0.15); let p8 = vec2<f32>(1.1, 0.15);
    var prev = p0; let samples: f32 = 40.0;
    for (var i: i32 = 1; i <= 40; i = i + 1) {
        let curr = bspline(p0, p1, p2, p3, p4, p5, p6, p7, p8, f32(i) / samples);
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            let x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) { count = count + 1; }
        }
        prev = curr;
    }
    return count;
}

fn bsplineLid(t: f32) -> vec2<f32> {
    let p0 = vec2<f32>(1.3, 2.25); let p1 = vec2<f32>(1.2, 2.25); let p2 = vec2<f32>(1.18, 2.25);
    let p3 = vec2<f32>(1.15, 2.15); let p4 = vec2<f32>(1.1, 2.2); let p5 = vec2<f32>(1.0, 2.32);
    let p6 = vec2<f32>(0.5, 2.35); let p7 = vec2<f32>(0.07, 2.48); let p8 = vec2<f32>(0.07, 2.66);
    let p9 = vec2<f32>(0.26, 2.87); let p10 = vec2<f32>(0.2, 2.91); let p11 = vec2<f32>(0.05, 2.91);
    let mt = t * 9.0; let seg = i32(floor(mt)); let f = mt - f32(seg);
    if (seg == 0) { return bezier(p0, p1, p2, (p2+p3)*0.5, f); }
    if (seg == 8) { return bezier((p8+p9)*0.5, p9, p10, p11, f); }
    var pts = array<vec2<f32>, 12>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
    let c0 = (pts[seg]+pts[seg+1])*0.5; let c1 = pts[seg+1]; let c2 = pts[seg+2]; let c3 = (pts[seg+2]+pts[seg+3])*0.5;
    return bezier(c0, c1, c2, c3, f);
}

fn intersectBSplineLid(p: vec2<f32>) -> i32 {
    var count: i32 = 0; var prev = vec2<f32>(1.3, 2.25); let samples: f32 = 50.0;
    for (var i: i32 = 1; i <= 50; i = i + 1) {
        let curr = bsplineLid(f32(i) / samples);
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            let x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) { count = count + 1; }
        }
        prev = curr;
    }
    return count;
}

fn isInsideBody(xyz: vec3<f32>, outside: bool) -> bool {
    let r = length(xyz.xz); let p = vec2<f32>(r, xyz.y); var count: i32 = 0;
    if (outside) {
        count = count + intersectBezier(p, vec2<f32>(1.4, 2.25), vec2<f32>(1.3375, 2.38125), vec2<f32>(1.4375, 2.38125), vec2<f32>(1.5, 2.25));
        count = count + intersectBezier(p, vec2<f32>(1.5, 2.25), vec2<f32>(1.75, 1.725), vec2<f32>(2.0, 1.2), vec2<f32>(2.0, 0.75));
        count = count + intersectBezier(p, vec2<f32>(2.0, 0.75), vec2<f32>(2.0, 0.3), vec2<f32>(1.5, 0.075), vec2<f32>(1.5, 0.0));
        count = count + intersectLine(p, vec2<f32>(1.5, 0.0), vec2<f32>(0.0, 0.0));
        count = count + intersectLine(p, vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 2.25));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.25), vec2<f32>(1.4, 2.25));
    } else {
        count = count + intersectBSpline(p);
        count = count + intersectLine(p, vec2<f32>(1.1, 0.15), vec2<f32>(0.0, 0.15));
        count = count + intersectLine(p, vec2<f32>(0.0, 0.15), vec2<f32>(0.0, 2.25));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.25), vec2<f32>(1.4, 2.25));
    }
    return (count % 2) != 0;
}

fn isInsideLid(xyz: vec3<f32>, outside: bool) -> bool {
    let r = length(xyz.xz); let p = vec2<f32>(r, xyz.y); var count: i32 = 0;
    if (outside) {
        count = count + intersectBezier(p, vec2<f32>(0.01, 3.0), vec2<f32>(0.8, 3.0), vec2<f32>(0.0, 2.7), vec2<f32>(0.2, 2.55));
        count = count + intersectBezier(p, vec2<f32>(0.2, 2.55), vec2<f32>(0.4, 2.4), vec2<f32>(1.3, 2.4), vec2<f32>(1.3, 2.25));
        count = count + intersectLine(p, vec2<f32>(1.3, 2.25), vec2<f32>(0.0, 2.25));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.25), vec2<f32>(0.0, 3.0));
        count = count + intersectLine(p, vec2<f32>(0.0, 3.0), vec2<f32>(0.01, 3.0));
    } else {
        count = count + intersectBSplineLid(p);
        count = count + intersectLine(p, vec2<f32>(0.05, 2.91), vec2<f32>(0.0, 2.91));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.91), vec2<f32>(0.0, 2.25));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.25), vec2<f32>(1.3, 2.25));
    }
    return (count % 2) != 0;
}

fn projectToBezier(q: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>) -> f32 {
    var bestT: f32 = 0.5; var minDist: f32 = 1e10;
    for (var i: i32 = 0; i <= 10; i = i + 1) {
        let t = f32(i) / 10.0; let d = length(q - bezier(p0, p1, p2, p3, t));
        if (d < minDist) { minDist = d; bestT = t; }
    }
    var delta: f32 = 0.05;
    for (var j: i32 = 0; j < 3; j = j + 1) {
        let t1 = clamp(bestT - delta, 0.0, 1.0); let t2 = clamp(bestT + delta, 0.0, 1.0);
        let d1 = length(q - bezier(p0, p1, p2, p3, t1)); let d2 = length(q - bezier(p0, p1, p2, p3, t2));
        if (d1 < d2) { if (d1 < minDist) { minDist = d1; bestT = t1; } }
        else { if (d2 < minDist) { minDist = d2; bestT = t2; } }
        delta = delta * 0.5;
    }
    return bestT;
}

fn isInsideHandle(xyz: vec3<f32>) -> bool {
    let p0 = vec2<f32>(-1.55, 1.9875); let p1 = vec2<f32>(-2.4, 1.9875); let p2 = vec2<f32>(-2.85, 1.9875); let p3 = vec2<f32>(-2.85, 1.65);
    let p4 = vec2<f32>(-2.85, 1.3125); let p5 = vec2<f32>(-2.575, 0.88125); let p6 = vec2<f32>(-1.95, 0.6);
    let t1 = projectToBezier(xyz.xy, p0, p1, p2, p3); let d1 = length(xyz.xy - bezier(p0, p1, p2, p3, t1));
    let t2 = projectToBezier(xyz.xy, p3, p4, p5, p6); let d2 = length(xyz.xy - bezier(p3, p4, p5, p6, t2));
    let d = min(d1, d2); let r_xy = 0.15; let r_z = 0.225;
    return (d*d)/(r_xy*r_xy) + (xyz.z*xyz.z)/(r_z*r_z) < 1.0;
}

fn isInsideSpout(xyz: vec3<f32>, outside: bool) -> bool {
    let p0 = vec2<f32>(1.7, 0.8625); let p1 = vec2<f32>(2.85, 0.975); let p2 = vec2<f32>(2.35, 1.9125); let p3 = vec2<f32>(3.0, 2.25);
    let p4 = vec2<f32>(3.0, 2.25); let p5 = vec2<f32>(3.1625, 2.334375); let p6 = vec2<f32>(3.175, 2.34375); let p7 = vec2<f32>(3.0, 2.25);
    let t1 = projectToBezier(xyz.xy, p0, p1, p2, p3); let d1 = length(xyz.xy - bezier(p0, p1, p2, p3, t1));
    let t2 = projectToBezier(xyz.xy, p4, p5, p6, p7); let d2 = length(xyz.xy - bezier(p4, p5, p6, p7, t2));
    var d = d1; var t = t1; if (d2 < d1 && xyz.x > 2.7) { d = d2; t = 1.0; }
    var r_xy_out = mix(0.4125, 0.3, t); var r_z_out = mix(0.495, 0.1875, t);
    if (t == 1.0 && d == d2) { r_xy_out = 0.2; r_z_out = 0.1125; }
    if (!outside) {
        let r_xy_in = r_xy_out * 0.666; let r_z_in = r_z_out * 0.6;
        return (d*d)/(r_xy_in*r_xy_in) + (xyz.z*xyz.z)/(r_z_in*r_z_in) < 1.0;
    }
    return (d*d)/(r_xy_out*r_xy_out) + (xyz.z*xyz.z)/(r_z_out*r_z_out) < 1.0;
}

fn mainModel4(xyz: vec3<f32>) -> vec4<f32> {
    let spoutSolid = isInsideSpout(xyz, true) && !isInsideSpout(xyz, false);
    let bodySolid = isInsideBody(xyz, true) && !isInsideBody(xyz, false);
    let lidSolid = isInsideLid(xyz, true) && !isInsideLid(xyz, false);
    let handleSolid = isInsideHandle(xyz);
    if (bodySolid || spoutSolid || lidSolid || handleSolid) { return vec4<f32>(1.0, 0.0, 0.0, 0.0); }
    return vec4<f32>(0.0, 0.0, 0.0, 0.0);
}
